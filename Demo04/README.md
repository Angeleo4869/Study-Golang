### Demo04
#### 一、[数组](ARRAYS/main.go)：
数组是一种数据元素类型的集合，在Go语言中，数组从声明时就确定，使用时可以修改数组成员，但数组大小不可改变。基本语法
```go
//定义一个长度为 n 的整型数组
var a [n]int
```
1. 数组声明
    ```go
    var 数组变量名 [元素数量]T
    ```
    数组的长度必须为常量，并且长度是数组类型的一部分。一旦定义，数组的长度不可修改。

    数组声明后，其每个元素的初始值为其对应元素类型的默认值

    数组声明并赋值
    ```go
    var array = [n]T{1,2,3,...,n}
    ```
    声明数组时可以根据初始值自动判定数组长度
    ```go
    var array = [...]T{1,2,3,...,n}
    len := len(array) //len = n
    ```
    根据索引初始化对应元素值
    ```go
    var array = [5]int{0 : 1 , 4 : 2}
    //array = { 1, 0, 0, 0, 2}
    ```
2. 数组遍历
    1. for循环遍历
    ```go
    var a = [4]int{1,2,3}
	for i := 0; i < len(a) ;i++ {
		fmt.Printf("%d ",a[i])
    }
    ```
    2. for range 遍历
    ```go
    var a = [4]int{1,2,3}
    for index, value := range a {
        fmt.Printf("%d %d\n",index,value)
    }
    ```
3. 多维数组
    声明一个n*m的二维数组：
    ```go
    var arrays [n][m]T

    var arrays2 = [2][3]int{ //声明一个2*3 的整型数组并初始化
                {1,2,3},
                {4,5,6}
            }
    ```
注：
1、数组支持 `==`、`!=`操作符，因为内存是被初始化过的

2、`[n]*T`表示数组指针，`*[n]T`表示指针数组

#### 二、[切片](SLICE/main.go)：
切片（Slice）是一个拥有相同元素类型的可变长度的序列。它是基于数组类型做的一层封装。它非常灵活，支持自动扩容。

切片是一个引用类型，它的内部包含`地址`、`长度`和`容量`。

切片一般用于快速地操作一块数据集合。
1. 切片的声明：
```go
var name []T
```
切片的声明与初始化方式跟数组一样，只是没有固定长度

2. 切片的长度和容量
切片拥有自己的长度和容量，可以通过 `len()`函数求长度，通过 `cap()`函数求容量
3. 基于数组定义切片
由于切片的底层就是数组，我们可以基于数组定义切片
```go
array := [...]int{1,2,3,4,5,6,7}
slice1 := array[n:m]//表示从n 到 m的切片，左闭右包
slice2 := array[:m]//表示从0 到 m的切片，左闭右包
slice3 := array[n:]//表示从n 到 end的切片，左闭右包
slice4 := array[:]//表示从0 到 end的切片，左闭右包
```
切片的容量是指底层数组的容量

底层数组，从切片的第一个元素到最后一个元素的数量

即从 `n` 开始到 `end`

切片是一个引用类型，底层数组改变，切片的值就会发生改变
4. 使用make()构造动态切片
以上切片都是基于数组来创建的，如果需要实现动态切片，需要使用内置函数`make()`，格式如下：
```go
make([]T, size, cap)
```
5. 切片的本质
切片就是一块连续内存的窗口，属于引用类型，真正的数据保存在底层数组里。

多个切片引用同一个底层数组，当其中一个值改变时，另一个也会改变
  
6. 切片的比较
切片之间不能直接使用`==`操作符比较，切片唯一能合法的比较的是 `nil`，一个值为`nil`的切片没有底层数组，其长度和容量都是 0 ，但是长度和容量都为 0 的切片不一定为 `nil`。

判断切片是否为空应使用`len(slice) == 0`。

7. 切片的遍历
切片遍历与数组遍历一样，可以使用索引和`for range`遍历。